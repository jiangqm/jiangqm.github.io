[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-01-17T08:02:29.892Z","categories_index":"","tags_index":"","author_index":"kermit"},{"id":"00cded0b700d2d3ec74ef7677b631c20","title":"前端SEO优化","content":"前端SEO优化简介\n\n\n\n\n\n\n\n\nSEO是Search Engine Optimization的缩写，即：搜索引擎优化，指通过了解搜索引擎原理和其运算法则的理解，在其基础之上，对网站进行内外部调优，改进网站在搜索引擎中的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，提高用户体验（UE）和转化率进而创造价值。\n如何优化一、合理的title 、description 、keywords​        搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。\n\ntitle：浏览器的标题，一般不超过80字符，词语间用”**-**“隔开\n&lt;title>网站标题&lt;/title>\ndescription ：网站的描述，一般不超过150字符\n&lt;meta name=”Description” Content=”你网页的简述”>\nkeywords：网站的关键字，主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。\n&lt;meta name=”Keywords” Content=”关键词1,关键词2,关键词3,″>\n\n二、标签语义化1. 什么是标签语义化​    用恰当的标签来标记内容，通俗的说，就是告诉你：“这是一个一级标题或二级标题”，“这是一个段落”，“这是头部”，“这是一个导航栏”，并不会告诉你：“这是红色的”，“这个有多么宽，多么高”。标题脱了CSS这层外衣，它还是一个标题。\n2. 写HTML代码时需要注意的点\n尽量少用无语义的标签，如**div和span**\n\n不要使用纯样式标签，如：b、font、u等，改用css设置。\n\n需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；\n\n使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；\n\n\n3. 常用的语义元素HTML5提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素”，如图所示\n\n常用的语义化元素：\n\nheader : 代表网页或section的页眉\n\nfooter: 代码网页的页尾\n\nh1~6 ：代表段落的标题\n\nnav：页面的导航\n…..\n\n\n三、代码的优化\n跳转的链接尽量用a标签或者框架自带的Link标签去跳转，少用router.push这类的编程式导航\n\nimg标签应该使用alt属性对图像进行说明\n\n\n\n\n\n\n\n\n\nalt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n&lt;img src=\"cat.jpg\" width=\"300\" height=\"200\" alt=\"猫\"  />\n\n\n当网站由于网站url链接不一样但网页内容是一样而造成重复收录被降权的问题应该使用ref=‘canonical’\n需要注意的是link标签里的url链接是你所认为的规范、正确、希望百度收录且参与排名的那个链接。写好这段代码之后，将其放入非权威的网页的头部中即可。\n\n相同链接的示例：\n/search?q=Mirrors&amp;vehicle[model]=230i&amp;vehicle[make]=BMW&amp;vehicle[year]=2022\n\n/search?q=Mirrors&amp;vehicle[model]=a4&amp;vehicle[make]=Audi&amp;vehicle[year]=2022\n如何使用：\n&lt;head>\n\t&lt;link rel=\"canonical\" href=\"http://www.xxxx.com/search\" />  \n&lt;/head>\n\n\n\n四、URL的优化\nurl层级不宜过深，正常来说最长四级即可\n\nurl应当是可以描述访问内容的路径，用户根据url就能知道自己要访问的内容\n/login # 登录页\n\n/users/info #用户信息\n\n/detail/325955167985312  # /product/[:id]  or /product/[:skuLink]  商品详情页\n\n/collection/Mirrors  # /collection/[:类目名称]   类目相关页面\n用面包屑的方式便于增加内链爬取\n\n\n\n\n\n\n\n\n\n内链：内链是自己网站的一个页面指向自己网站的另外一个页面\n外链：外链则是其他人网站上的一个链接指向了你网站中的任何一个页面。\n\n更好链接时使用301状态码不使用302状态码，301对爬虫友好\n\n\n\n\n\n\n\n\n\n301 ：永久重定向\n302 ：临时重定向\n\n\n","slug":"前端SEO优化","date":"2022-03-28T09:32:48.000Z","categories_index":"","tags_index":"","author_index":"kermit"},{"id":"d52b99c18188db71b708cd776c1bca0b","title":"Webapck","content":"Webapck\n\n\n\n\n\n\n\n\nver 5\n基本概念入口（entry）​    入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n默认值是 ./src/index.js，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点。例如：\nmodule.exports = &#123;\n  entry: './path/to/my/entry/file.js',\n&#125;;\n\n出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。\n你可以通过在配置中指定一个 output 字段，来配置这些处理过程：\nconst path = require('path');\n\nmodule.exports = &#123;\n  entry: './path/to/my/entry/file.js',\n  output: &#123;\n    path: path.resolve(__dirname, 'dist'), // 打包文件生成路径\n    filename: 'my-first-webpack.bundle.js', // 文件名\n  &#125;,\n&#125;;\n\n转换器(loader)webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中\n在更高层面，在 webpack 的配置中，loader 有两个属性：\n\ntest 属性，识别出哪些文件会被转换。\nuse 属性，定义出在进行转换时，应该使用哪个 loader。\n\nconst path = require('path');\n// 是\nmodule.exports = &#123;\n  output: &#123;\n    filename: 'my-first-webpack.bundle.js',\n  &#125;,\n  module: &#123;\n      // 以.txt结尾的文件都用raw-loader转换一下\n    rules: [&#123; test: /\\.txt$/, use: 'raw-loader' &#125;],\n  &#125;,\n&#125;;\n\n插件(plugin)loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。\n想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nconst webpack = require('webpack'); // 用于访问内置插件\n\nmodule.exports = &#123;\n  module: &#123;\n    rules: [&#123; test: /\\.txt$/, use: 'raw-loader' &#125;],\n  &#125;,\n  plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;)],\n&#125;;\n\n在上面的示例中，html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。\n模式(mode)通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。\nmodule.exports = &#123;\n  mode: 'production',\n&#125;;\n\n入口单个入口用法：entry: string | [string]\nmodule.exports = &#123;\n  entry: './path/to/my/entry/file.js',\n&#125;;\n\n上面的写法相当于\nmodule.exports = &#123;\n  entry: &#123;\n    main: './path/to/my/entry/file.js',\n  &#125;,\n&#125;;\n\n多入口\n我们也可以将一个文件路径数组传递给 entry 属性，这将创建一个所谓的 **”multi-main entry”**。在你想要一次注入多个依赖文件，并且将它们的依赖关系绘制在一个 “chunk” 中时，这种方式就很有用。\nmodule.exports = &#123;\n  entry: ['./src/file_1.js', './src/file_2.js'],\n  output: &#123;\n    filename: 'bundle.js',\n  &#125;,\n&#125;;\n\n对象语法用法：entry: &#123; &lt;entryChunkName&gt; string | [string] &#125; | &#123;&#125;\nmodule.exports = &#123;\n  entry: &#123;\n    app: './src/app.js',\n    adminApp: './src/adminApp.js',\n  &#125;,\n&#125;;\n\n对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。\n描述入口的对象用于描述入口的对象。你可以使用如下属性：\n\ndependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载。\nfilename: 指定要输出的文件名称。\nimport: 启动时需加载的模块。\nlibrary: 指定 library 选项，为当前 entry 构建一个 library。\nruntime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。\npublicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。请查看 output.publicPath。\n\nmodule.exports = &#123;\n  entry: &#123;\n    a2: 'dependingfile.js',\n    b2: &#123;\n      dependOn: 'a2',\n      import: './src/app.js',\n    &#125;,\n  &#125;,\n&#125;;\n\ntips\nruntime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会抛出错误：\nmodule.exports = &#123;\n  entry: &#123;\n    a2: './a',\n    b2: &#123;\n      runtime: 'x2',\n      dependOn: 'a2',\n      import: './b',\n    &#125;,\n  &#125;,\n&#125;;\n\n确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：\nmodule.exports = &#123;\n  entry: &#123;\n    a1: './a',\n    b1: &#123;\n      runtime: 'a1',\n      import: './b',\n    &#125;,\n  &#125;,\n&#125;;\n\n另外 dependOn 不能是循环引用的，下面的例子也会出现错误：\nmodule.exports = &#123;\n  entry: &#123;\n    a3: &#123;\n      import: './a',\n      dependOn: 'b3',\n    &#125;,\n    b3: &#123;\n      import: './b',\n      dependOn: 'a3',\n    &#125;,\n  &#125;,\n&#125;;\n\n出口(output)可以通过配置 output 选项，告知 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 entry 起点，但只能指定一个 output 配置\nmodule.exports = &#123;\n  output: &#123;\n    filename: 'bundle.js',\n  &#125;,\n&#125;;\n\n此配置将一个单独的 bundle.js 文件输出到 dist 目录中。\n多个入口起点如果配置中创建出多于一个 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用 占位符(substitutions) 来确保每个文件具有唯一的名称。\nmodule.exports = &#123;\n  entry: &#123;\n    app: './src/app.js',\n    search: './src/search.js',\n  &#125;,\n  output: &#123;\n    filename: '[name].js',\n    path: __dirname + '/dist',\n  &#125;,\n&#125;;\n\n// 写入到硬盘：./dist/app.js, ./dist/search.js\n\nLoader在你的应用程序中，有两种使用 loader 的方式：\n\n配置方式（推荐）：在 webpack.config.js 文件中指定 loader。\n内联方式：在每个 import 语句中显式指定 loader。\n\n注意在 webpack v4 版本可以通过 CLI 使用 loader，但是在 webpack v5 中被弃用\n配置方式module.rules 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让你对各个 loader 有个全局概览：\nloader 从右到左（或从下到上）地取值(evaluate)/执行(execute)。在下面的示例中，从 sass-loader 开始执行，然后继续执行 css-loader，最后以 style-loader 为结束。查看 loader 功能 章节，了解有关 loader 顺序的更多信息。\nmodule.exports &#x3D; &#123;\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.css$&#x2F;,\n        use: [\n          &#x2F;&#x2F; [style-loader](&#x2F;loaders&#x2F;style-loader)\n          &#123; loader: &#39;style-loader&#39; &#125;,\n          &#x2F;&#x2F; [css-loader](&#x2F;loaders&#x2F;css-loader)\n          &#123;\n            loader: &#39;css-loader&#39;,\n            options: &#123;\n              modules: true\n            &#125;\n          &#125;,\n          &#x2F;&#x2F; [sass-loader](&#x2F;loaders&#x2F;sass-loader)\n          &#123; loader: &#39;sass-loader&#39; &#125;\n        ]\n      &#125;\n    ]\n  &#125;\n&#125;;\n\n内联方式可以在 import 语句或任何 与 “import” 方法同等的引用方式 中指定 loader。使用 ! 将资源中的 loader 分开。每个部分都会相对于当前目录解析。\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\n\nloader特性\nloader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。\nloader 可以是同步的，也可以是异步的。\nloader 运行在 Node.js 中，并且能够执行任何操作。\nloader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。\n除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。\n插件(plugin)可以为 loader 带来更多特性。\nloader 能够产生额外的任意文件。\n\n可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言转译（或编译）和 更多其他特性。\n解析loaderloader 遵循标准 模块解析 规则。多数情况下，loader 将从 模块路径 加载（通常是从 npm install, node_modules 进行加载）。\n我们预期 loader 模块导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。通常使用 npm 进行管理 loader，但是也可以将应用程序中的文件作为自定义 loader。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。更多详细信息，请查看 编写一个 loader。\n编写自己的loader一个loader 的本质就是一个nodejs模块，这个模块导出一个函数，这个导出函数的工作就是**获取处理前的内容(source参数的值)**，返回处理后的内容\n一个最简单的loader源码如下：\nmodule.exports = function(source)&#123;\n    // 这边不做处理直接返回\n    return source\n&#125;\n\n由于loader是运行在nodeJs环境中，所以可以调用nodejs的API或者安装第三方插件\nconst sass = require('node-sass')\nmodule.exports = function(source)&#123;\n    //  这边调用sass插件对资源进行转换，返回转换后的资源\n    return sass(source)\n&#125;\n\nwebpack.config.js引入自定义loader需要path.reslove转换下，不能直接require引入\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");\nmodule.exports = &#123;\n  mode: \"development\",\n  entry: path.resolve(__dirname, \"./src/main.js\"), // 入口文件\n  output: &#123;\n    filename: \"[name].[hash:8].js\", // 打包后的文件名称\n    path: path.resolve(__dirname, \"dist\"), // 打包后的目录\n  &#125;,\n  module: &#123;\n      // .txt后缀的文件用自定义loader解析\n    rules: [\n      &#123;\n        test: /\\.txt$/,\n        use: [\n          &#123;loader:path.resolve(\"./src/loader/myloader\")&#125;\n        ],\n      &#125;,\n    ],\n  &#125;,\n\n  plugins: [\n    // 打包前删除原先的打包目录\n    new CleanWebpackPlugin(),\n    new HtmlWebpackPlugin(&#123;\n      //配置静态模板\n      template: path.resolve(__dirname, \"./public/index.html\"),\n    &#125;),\n  ],\n&#125;;\n\n\n\n\nPlugin剖析webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且在 整个 编译生命周期都可以访问 compiler 对象。\n自定义PluginConsoleLogOnBuildWebpackPlugin.js\nconst pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin &#123;\n  apply(compiler) &#123;\n    compiler.hooks.run.tap(pluginName, (compilation) => &#123;\n      console.log('webpack 构建正在启动！');\n    &#125;);\n  &#125;\n&#125;\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\n\ncompiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中重复使用。\n","slug":"Webapck","date":"2022-03-27T11:22:08.000Z","categories_index":"","tags_index":"","author_index":"kermit"}]